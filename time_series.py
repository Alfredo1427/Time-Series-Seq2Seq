# -*- coding: utf-8 -*-
"""Time Series.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VMXpPSksiCU5nmBWED0G9I9SoE47-EWJ
"""

#pip install pandas numpy scikit-learn tensorflow

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, LSTM, RepeatVector, TimeDistributed, Dense
import os

input_steps = 1000  # e.g. 10 past time steps
output_steps = 1000  # e.g. predict next 5 steps
feature_column = 'value'  # column to use for forecasting
file = '/content/1.xlsx'
output_file = '/content/2.xlsx'

df = pd.read_excel(file)
series = df[['Inlet Gas']].values  # keep as 2D array

scaler = MinMaxScaler()
series_scaled = scaler.fit_transform(series)

# --- CREATE SEQUENCES ---
def create_seq2seq_data(data, input_len, output_len):
    X, y = [], []
    # Ensure there are enough data points to create sequences
    if len(data) < input_len + output_len:
        print("Error: Not enough data to create sequences with the specified input and output lengths.")
        return np.array(X), np.array(y)

    for i in range(len(data) - input_len - output_len + 1):
        X.append(data[i:i + input_len])
        y.append(data[i + input_len:i + input_len + output_len])
    return np.array(X), np.array(y)

X, y = create_seq2seq_data(series_scaled, input_steps, output_steps)
print(f"Input shape: {X.shape}, Output shape: {y.shape}")

# --- BUILD SEQ2SEQ MODEL ---
latent_dim = 64

encoder_inputs = Input(shape=(input_steps, 1))
encoder_lstm = LSTM(latent_dim, return_state=True)
_, state_h, state_c = encoder_lstm(encoder_inputs)
encoder_states = [state_h, state_c]

decoder_inputs = RepeatVector(output_steps)(state_h)
decoder_lstm = LSTM(latent_dim, return_sequences=True)
decoder_outputs = decoder_lstm(decoder_inputs, initial_state=encoder_states)
decoder_outputs = TimeDistributed(Dense(1))(decoder_outputs)

model = Model(encoder_inputs, decoder_outputs)
model.compile(optimizer='adam', loss='mse')

# --- TRAIN ---
# Ensure batch size is not greater than the number of samples
batch_size = min(32, X.shape[0])
if batch_size == 0:
    print("Error: No samples to train on.")
else:
    model.fit(X, y, epochs=5, batch_size=batch_size, validation_split=0.1)

# --- INFERENCE & EXPORT ---
X_test = X[-1:]  # last known sequence
y_pred = model.predict(X_test)
y_pred_rescaled = scaler.inverse_transform(y_pred.reshape(-1, 1))

# Export to CSV
predicted_df = pd.DataFrame(y_pred_rescaled, columns=['forecast'])
predicted_df.to_excel(output_file, index=False)
print(f"Forecast saved to {output_file}")